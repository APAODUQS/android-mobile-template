apply plugin: 'com.android.application'
project.ext {
    defaultRunner = "cucumber"
}

repositories {
    /**
     * Add the maven repository to get the external libraries in this case using the nexus repository
     */
    maven { url "http://192.168.243.3:8111/nexus/content/repositories/snapshots" }
    maven { url "http://192.168.243.3:8111/nexus/content/repositories/releases" }
    maven { url "http://192.168.243.3:8111/nexus/content/repositories/thirdparty/" }
    maven { url 'https://raw.github.com/zeeshanejaz/unirest-android/mvn-repo' }
    google()
}
android {
    compileSdkVersion 29
    buildToolsVersion "29.0.2"
    defaultConfig {
        if (project.getProperty("defaultRunner").equals("cucumber")) {
            testInstrumentationRunner "automation.cucumber.runner.CucumberTestRunner"
        } else {
            testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        }
        applicationId "net.easysol.automation.did"
        testApplicationId "net.easysol.automation.did.test"
        minSdkVersion 21
        targetSdkVersion 29
        versionCode 1
        versionName "1.0"
        multiDexEnabled true
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        debug {
            debuggable true
            buildConfigField "String", "TEST_TAGS", "\"${getTestTags()}\""
        }
    }
    sourceSets {
        main.jniLibs.srcDirs = ['libs']
        test.jniLibs.srcDirs = ['libs']
        androidTest {
            assets.srcDirs = ['src/main/java/assets']
        }
        main { java.srcDirs = ['src/main/java', 'src/main/java/tests'] }
    }
    lintOptions {
        abortOnError false
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    packagingOptions {
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/license.txt'
        exclude 'META-INF/groovy-release-info.properties'
        exclude 'META-INF'
        exclude 'META-INF/notice.txt'
        exclude 'META-INF/spring.tooling'
        exclude 'META-INF/spring.handlers'
        exclude 'META-INF/spring.schemas'
        exclude 'androidsupportmultidexversion.txt'
    }
}

dependencies {

    implementation 'com.android.tools:desugar_jdk_libs:1.0.5'
    testImplementation 'junit:junit:4.13'
    androidTestImplementation('org.awaitility:awaitility:4.0.1') {
        exclude group: 'org.hamcrest'
    }

    implementation 'com.android.support:support-annotations:28.0.0'
    implementation 'com.android.support:multidex:1.0.3'
    implementation 'com.mashape.unirest:unirest-android:1.0+'

    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test:rules:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
    androidTestImplementation 'com.android.support:support-annotations:28.0.0'
    androidTestImplementation 'com.android.support.test.uiautomator:uiautomator-v18:2.1.3'
    implementation 'org.slf4j:slf4j-nop:1.7.25'
    //CUCUMBER
    androidTestImplementation('info.cukes:cucumber-android:1.2.5') {
        exclude module: 'cucumber-jvm-deps'
    }
    androidTestImplementation('info.cukes:cucumber-picocontainer:1.2.5') {
        exclude module: 'cucumber-jvm-deps'
    }
    androidTestImplementation 'info.cukes:cucumber-jvm-deps:1.0.5'
    androidTestImplementation("com.github.tomakehurst:wiremock:2.25.1") {
        exclude group: 'org.apache.httpcomponents', module: 'httpclient'
        exclude group: 'asm', module: 'asm'
        exclude group: 'org.json', module: 'json'
    }
    androidTestImplementation 'org.apache.httpcomponents:httpclient-android:4.3.5.1'
    androidTestImplementation 'com.google.code.gson:gson:2.8.6'

//    Support Stream
    def solidVersion = '2.0.3'
    implementation "info.android15.solid:streams:$solidVersion"
    implementation "info.android15.solid:collections:$solidVersion"


// ------------------------        DEPENDENCIES FOR DID MOBILE        ------------------------------

    def latestSDKVersion = "8.2.0"

    implementation "net.easysol:liveness:$latestSDKVersion@aar"
    implementation "com.cyxtera.did.sdk:data:$latestSDKVersion@aar"
    implementation "com.cyxtera.did.sdk:encryptor:$latestSDKVersion@aar"
    implementation "com.cyxtera.did.sdk:tokens:$latestSDKVersion@aar"
    implementation "com.cyxtera.did.sdk:faceid_detector:$latestSDKVersion@aar"
    implementation "com.cyxtera.did.sdk:faceid-authenticator-sdk:$latestSDKVersion@aar"
    implementation "com.cyxtera.did.sdk:sdk:$latestSDKVersion@aar"
    implementation "com.cyxtera.did.sdk:offline:$latestSDKVersion@aar"

    implementation 'androidx.appcompat:appcompat:1.1.0'
    implementation 'com.google.android.material:material:1.1.0'
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
    implementation 'androidx.mediarouter:mediarouter:1.1.0'
    implementation 'androidx.vectordrawable:vectordrawable-animated:1.1.0'
    implementation 'androidx.cardview:cardview:1.0.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'com.google.firebase:firebase-core:17.2.3'
    implementation 'com.google.code.gson:gson:2.8.6'
    implementation 'com.squareup.retrofit2:retrofit:2.6.2'
    implementation 'com.squareup.retrofit2:converter-gson:2.6.2'
    implementation 'com.squareup.okhttp3:logging-interceptor:4.2.2'
    annotationProcessor 'com.google.dagger:dagger-compiler:2.25.2'
    annotationProcessor 'com.google.dagger:dagger-android-processor:2.25.2'
    implementation('com.google.dagger:dagger-android-support:2.25.2', {
        exclude group: 'com.android.support'
    })
}

def getTestTags() {
    return project.hasProperty("tags") ? project.getProperties().get("tags") : ""
}

/**
 * Grant permissions to all connected devices
 */
task grantPermissions {
    dependsOn 'assembleDebug', 'assembleDebugAndroidTest', 'installDebug', 'installDebugAndroidTest', 'connectedDevicesTask'
    group 'did_automation'
    doLast {
        def adb = getAdbPath()
        def permissions = [
                'android.permission.WRITE_EXTERNAL_STORAGE',
                'android.permission.READ_EXTERNAL_STORAGE',
                'android.permission.READ_PHONE_STATE',
                'android.permission.ACCESS_FINE_LOCATION'
        ]
        def mainPackageName = android.defaultConfig.applicationId

        for (DeviceInfo connectedDevice : connectedDevices) {
                deletePackages(connectedDevice.serial)
            for (String permission : permissions) {
                exec {
                    commandLine adb, '-s', connectedDevice.serial, 'shell', 'pm', 'grant', mainPackageName, permission
                }
            }
        }
    }
}

/**
 * Get a specific property of a connected devices
 * @return String: value of the property of device
 */
def deletePackages(deviceId) {
    def adb = getAdbPath()
    def packageDelete = 'net.easysol.automation.did.test'
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine adb, '-s', deviceId, 'shell', 'pm', 'list', 'packages', '|grep', "$packageDelete"
        standardOutput = stdout
    }
    def packages = stdout.toString()
    if (packages.contains(packageDelete)) {
        exec {
            commandLine adb, '-s', deviceId, 'shell', 'pm', 'uninstall', "$packageDelete"
        }
    }
}

task connectedDevicesTask {
    doLast {
        project.ext.connectedDevices = getConnectedDevices()
    }
}

/**
 * Main task for running cucumber tests
 */
task exportCucumberReports {
    dependsOn 'connectedDevicesTask'
    dependsOn 'grantPermissions'
    group 'did_automation'
    doLast {
        def executionTime = Calendar.getInstance().getTime().toString().replaceAll('[: ]', '_').trim()
        def cucumberReportsPath = buildDir.path + "/reports/cucumber/"
        cucumberReportsPath += getFileCount(cucumberReportsPath) + '.' + executionTime

        connectedDevices.parallelStream().forEach({
            connectedDevice ->
                downloadCucumberReports(connectedDevice.serial, cucumberReportsPath)
        })
    }
}

/**
 * Model class for connected device information
 */
class DeviceInfo {
    String serial
}

/**
 * Cast ADB response for device to DeviceInfo class
 * @param infoArray line for one device obtained by "adb devices -l" command
 * @return DeviceInfo: model class for connected device information
 */
DeviceInfo castAdbDeviceToDeviceInfo(String[] infoArray) {
    return new DeviceInfo(
            serial: infoArray[0]
    )
}

/**
 * Get a list of connected devices
 * @return List: list of devices information
 */
List<DeviceInfo> getConnectedDevices() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine getAdbPath(), 'devices', '-l'
        standardOutput = stdout
    }
    String[] devicesInfoArray = stdout.toString().split('[\\r\\n]+')

    List<DeviceInfo> devices = new ArrayList<>()
    for (int i = 1; i < devicesInfoArray.length; ++i) {
        String[] infoArray = devicesInfoArray[i].split('\\s+')
        devices.push(castAdbDeviceToDeviceInfo(infoArray))
    }
    return devices
}

/**
 * Get a specific property of a connected devices
 * @return String: value of the property of device
 */
String getPropertyDevice(deviceId, propDevice) {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine getAdbPath(), '-s', deviceId, 'shell', 'getprop', propDevice
        standardOutput = stdout
    }
    String valuePropDevice = stdout.toString().split('[\\r\\n]+')
    return valuePropDevice
}

/**
 * Pull cucumber reports to project
 * @param deviceId the id of the device where reports are getting
 * @param cucumberReportsPath path of the device where reports are stored
 */
def downloadCucumberReports(deviceId, cucumberReportsPath) {
    def deviceSourcePath = getCucumberDevicePath(deviceId)
    def localReportPath = new File(cucumberReportsPath + '/' + deviceId)
    if (!localReportPath.exists()) {
        localReportPath.mkdirs()
    }
    if (!localReportPath.exists()) {
        throw new GradleException("Could not create $localReportPath")
    }
    def adb = getAdbPath()
    def files = getCucumberReportFileNames()
    files.each { fileName ->
        exec {
            commandLine adb, '-s', deviceId, 'pull', "$deviceSourcePath/$fileName", localReportPath
        }
        if (fileName == 'cucumber.json') {
            def localJsonReport = buildDir.path + '/reports/cucumber/' + deviceId + "-" + fileName
            exec {
                commandLine adb, '-s', deviceId, 'pull', "$deviceSourcePath/$fileName", localJsonReport
            }
            def jsonNameTestOld = "\"name\": \""
            def modelDevice = getPropertyDevice(deviceId, 'ro.product.model')
            def deviceBrand = getPropertyDevice(deviceId, 'ro.product.brand')
            def versionDevice = getPropertyDevice(deviceId, 'ro.build.version.release')
            def jsonNameTestNew = "\"name\": \"" + deviceId + '_' + deviceBrand + '_' + modelDevice + '_' + versionDevice + ' - '

            exec {
                commandLine 'sed', '-i.back', '-e', "s/$jsonNameTestOld/$jsonNameTestNew/g", localJsonReport
            }
        }
    }
}

/**
 * Obtain the number of files in a folder
 * @param path String: folder path
 * @return int: number of files in the path
 */
def getFileCount(path) {
    File f = new File(path)
    if (!f.exists()) {
        f.mkdirs()
    }
    return f.list().length + 1
}

/**
 * Utility method to get the full ADB path
 * @return the absolute ADB path
 */
String getAdbPath() {
    def adb = android.getAdbExecutable().toString()
    if (adb.isEmpty()) {
        throw new GradleException("Could not detect adb path")
    }
    return adb
}

/**
 * Sometime adb returns '\r' character multiple times.
 * @param s the original string returned by adb
 * @return the fixed string without '\r'
 */
static def fixAdbOutput(String s) {
    return s.replaceAll("[\r\n]+", "\n").trim()
}

/**
 * Runs the adb tool
 * @param program the program which is executed on the connected device
 * @return the output of the adb tool
 */
def executeAdb(String deviceId, String program) {
    def process = new ProcessBuilder(getAdbPath(), "-s", deviceId, "shell", program).redirectErrorStream(true).start()
    String text = new BufferedReader(new InputStreamReader(process.inputStream)).text
    return fixAdbOutput(text)
}

/**
 * Gets the 'external' storage path which is confusingly the internal storage of the phone.
 * @return
 */
def getExternalStoragePath(deviceId) {
    String r = executeAdb(deviceId, 'echo $EXTERNAL_STORAGE')
    if (!r.matches('(/[^/]+)+')) {
        throw new GradleException("Could not detect external storage path")
    }
    return r
}

/**
 * The path which is used to store the Cucumber files.
 * @return path of cucumber reports
 */
def getCucumberDevicePath(deviceId) {
    return getExternalStoragePath(deviceId) + '/did-mobile-automation/cucumber-reports'
}

/**
 * @return the known Cucumber report files/directories
 */
static def getCucumberReportFileNames() {
    return ['cucumber.json', 'cucumber.xml', 'cucumber-html-report']
}